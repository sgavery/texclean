#!/usr/bin/env python3

import os
import sys
import argparse
import re
import send2trash
import collections
import json

__version__ = "0.5.0"
versionstring = "%(prog)s " + __version__
texcleandescription =\
"""Move automatically generated (temporary) LaTeX files to trash. Supports files
generated by a number of common LaTeX packages. If no path is provided cleans
current directory. If a .tex or .ltx file is provided, then only cleans files
associated to the LaTeX file."""

texcleanclassificationdescription =\
"""Generated files are classified as auxillary, log, or include files. "Auxillary
files" are (La)TeX or data files that are used by various packages in subsequent
runs. "Log files" are log files documenting the LaTeX (or LaTeX package)
processing; in particular, these are not used on subsequent runs. "Include
files" are automatically generated (La)TeX files that end up being
(automatically) more or less directly included into the final document on
subsequent runs.

Let us give an example to clarify the distinction between "auxillary" and
"include files". LaTeX creates an .aux file that is used by LaTeX and LaTeX
packages to generate the document on subsequent runs, but does not have text or
data that is directly included into the document. We call this an "auxillary"
file. On the other hand, bibtex uses the .aux file along with a .bib file to
generate an "include" .bbl bibliography file. This is essentially included on
subsequent runs to create the bibliography."""

mastertexfiles = (".ltx", ".tex")
latexfilesdesc = "latexfiles.json"

with open(os.path.join(os.path.dirname(os.path.abspath(__file__)), latexfilesdesc)) as fin:
    filetypes = json.load(fin)

logextensions = list(map(lambda e: e["extension"], filter(lambda e: e.get("type", "unknown") == "log", filetypes)))
auxextensions = list(map(lambda e: e["extension"], filter(lambda e: e.get("type", "unknown") == "auxillary", filetypes)))
incextensions = list(map(lambda e: e["extension"], filter(lambda e: e.get("type", "unknown") == "include", filetypes)))
allextensions = logextensions + auxextensions + incextensions

alltemppattern = re.compile(".*({})$".format("|".join(map(re.escape, allextensions))))
logpattern = re.compile(".*({})$".format("|".join(map(re.escape, logextensions))))
auxpattern = re.compile(".*({})$".format("|".join(map(re.escape, auxextensions))))
incpattern = re.compile(".*({})$".format("|".join(map(re.escape, incextensions))))


def readable_dir_or_tex(path):
    if os.path.isfile(path):
        if os.path.splitext(path)[1] in mastertexfiles:
            return path
        else:
            raise argparse.ArgumentTypeError("file {} does not have a recognized (La)TeX extension".format(path))
    if not os.path.isdir(path):
        raise argparse.ArgumentTypeError("path:{0} is not a valid path".format(path))
    if os.access(path, os.R_OK | os.W_OK):
        return path
    else:
        raise argparse.ArgumentTypeError("path:{0} is not a read-writeable directory".format(path))


def texclean_parseargs(argv):
    parser = argparse.ArgumentParser(prog="texclean",
                                     description=texcleandescription,
                                     epilog=texcleanclassificationdescription,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("--verbose", "-v", action="store_true", default=False)
    parser.add_argument("--version", "-V", action="version", version=versionstring)
    parser.add_argument("-i", "--interactive", action="store_true", default=False, help="prompt before each removal")
    parser.add_argument("path", nargs="?", type=readable_dir_or_tex, default=os.getcwd(), help="directory or LaTeX file")
    parser.add_argument("--dry-run", action="store_true", default=False, help="verbosely simulate run without actually trashing")
    parser.add_argument("-t", "--type-desc", action="store_true", default=False, help="print out file type descriptions")

    # parser.add_argument("-E", "--all-tmp", action="store_true", default=True, help="trash all temporary files (default)")
    parser.add_argument("--table", action="store_true", default=False, help="print LaTeX file type table and exit")

    loggroup = parser.add_mutually_exclusive_group()
    loggroup.add_argument("-L", "--logs", action="store_true", default=True, help="(default) trash log files")
    loggroup.add_argument("-l", "--leave-logs", action="store_true", default=False, help="exclude log files")

    auxgroup = parser.add_mutually_exclusive_group()
    auxgroup.add_argument("-A", "--auxs", action="store_true", default=True, help="(default) trash auxillary files")
    auxgroup.add_argument("-a", "--leave-auxs", action="store_true", default=False, help="exclude auxillary files")

    incgroup = parser.add_mutually_exclusive_group()
    incgroup.add_argument("-C", "--incs", action="store_true", default=True, help="(default) trash include files")
    incgroup.add_argument("-c", "--leave-incs", action="store_true", default=False, help="exclude include files")

    return parser.parse_args(argv[1:])


def normalize_args(args):
    if args.dry_run or args.type_desc or args.interactive:
        args.verbose = True
    if args.leave_logs:
        args.logs = False
    if args.leave_auxs:
        args.auxs = False
    if args.leave_incs:
        args.incs = False


def matchfile(filename, logs=True, auxs=True, incs=True):
    if incs and logs and auxs:
        return alltemppattern.match(filename) is not None

    if logs:
        if logpattern.match(filename):
            return True
    if auxs:
        if auxpattern.match(filename):
            return True
    if incs:
        if incpattern.match(filename):
            return True

    return False


def getfiledescription(fname):
    ext = os.path.splitext(fname)[1]
    return filetypedictToString(next((e for e in filetypes if re.match(".*{}$".format(e["extension"]), fname)), None))


def filetypedictToString(filetypedict):
    if not filetypedict:
        return "no description"
    creator = filetypedict.get("creator", "LaTeX").strip()
    name = filetypedict.get("name", "").strip()
    filecat = filetypedict.get("type", "misc.").strip()
    if name.endswith("file"):
        name = name[:-4].strip()
    if name.startswith(creator):
        return "{} file ({})".format(name, filecat)
    return "{} {} file ({})".format(creator, name, filecat)


def getlatexfiles(argpath, logs, auxs, incs):
    if os.path.isfile(argpath):
        texfilepath, texfilename = os.path.split(argpath)
        texfilebase = os.path.splitext(texfilename)[0]
        return filter(lambda fname: fname.startswith(texfilebase) and
                      os.path.isfile(os.path.join(texfilepath, fname)) and
                      matchfile(fname, logs, auxs, incs), os.listdir(texfilepath))

    return filter(lambda fname: os.path.isfile(os.path.join(argpath, fname)) and
                  matchfile(fname, logs, auxs, incs), os.listdir(argpath))


def closingmessage(printfunc, num_dels, num_failed, argpath, simulated=False):
    simstring = "[Simulated] " if simulated else ""
    if num_dels > 0:
        printfunc("{}Succesfully trashed {} files.".format(simstring, num_dels), flush=True)

    if num_failed > 0:
        print("{} files failed!".format(num_failed), file=sys.stderr)
    elif num_dels == 0:
        printfunc("No (La)TeX temporary files matching conditions found in {}.".format(argpath))


def printlatexfilestable():
    # To do: sort table by type
    for filetypedict in filetypes:
        print("{:<12} {}".format(filetypedict.get("extension", ".???"), filetypedictToString(filetypedict)))


def main(argv=[]):
    args = texclean_parseargs(argv)
    normalize_args(args)

    if args.table:
        printlatexfilestable()
        return 0

    if args.verbose:
        def verboseprint(*args, **kwargs):
            print(*args, **kwargs)
    else:
        def verboseprint(*args, **kwargs):
            pass

    num_dels = 0
    num_failed = 0

    file_iter = getlatexfiles(args.path, args.logs, args.auxs, args.incs)

    for filename in file_iter:
        if args.type_desc:
            filedesc = getfiledescription(filename)
            verboseprint("Trashing {::<25}{:.<50}".format(filename[-24:], "[{:<.48}]".format(filedesc)), end="...", flush=True)
        else:
            verboseprint("Trashing {:.<50}".format(filename[-50:]), end="...", flush=True)

        if args.interactive:
            aborted = input("[yn]?") not in ("y", "Y")
            if aborted:
                num_failed += 1
                verboseprint("aborted.")
                continue

        if args.dry_run:
            num_dels += 1
            verboseprint("done.")
        else:
            try:
                send2trash.send2trash(os.path.join(args.path, filename))
            except OSError as err:
                num_failed += 1
                verboseprint("Failed!")
                print("\t", err)
            else:
                num_dels += 1
                verboseprint("done.")

    closingmessage(printfunc=verboseprint, num_dels=num_dels, num_failed=num_failed,
                   argpath=args.path, simulated=args.dry_run)

    if num_failed > 0:
        return 1
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))
